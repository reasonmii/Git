▶ Discarding Changes
Suppose you've made some changes to a file but don't want to keep them
To revert the file back to whatever it looked like when you last committed
you can use the commands below to discard any changes in that file,
reverting back to the HEAD

1) git checkout HEAD <filename>
2) git checkout -- <file>

$ cd desktop
$ mkdir animal
$ cd animal
$ git init
$ touch cat.txt dog.txt
$ git commit -m "add cat and dog files"

● Edit 'cat.txt' and 'dog.txt' files 3 times and commit each time
$ git add .
$ git commit -m "first commit"
$ git add .
$ git commit -m "second commit"
$ git commit -am "third commit"

$ git status
result : On branch master
         Changes not staged for commit:
           (use "git add <file>..." to update what will be committed)
           (use "git restore <file>..." to discard changes in working directory)
                 modified:   cat.txt
                 modified:   dog.txt
         no changes added to commit (use "git add" and/or "git commit -a")

● Edit 'cat.txt' and 'dog.txt' files and no commit yet
  Suppose you want to go back before editing
$ git checkout HEAD dog.txt
$ git checkout HEAD cat.txt

● Another code to discard changes
$ git checkout -- cat.txt dog.txt

$ git log --oneline
result : 0f1469a (HEAD -> master) third commit
         9f77adf second commit
         5dec360 first commit
-> We are in the last commit before being edited

------------------------------------------------------------------------------------------

▶ Restore
git restore is a brand new Git command that helps with undoing operations
git restore was introduced alongside git switch as alternatives
to some of the uses for checkout

▶ Unmodifying Files with Restore : git restore <file-name>
Suppose you've made some changes to a file since your last commit
You've saved the file but then realize you definitely do NOT want those changes anymore!
★ This is same as discarding changes
★ If you have uncommited changes in the file, they will be lost!
★ Git will let you know those commands when you type 'git status'

$ git restore dog.txt
$ git restore cat.txt

● To go back to the specific commit status
git restore <file-name> restores using HEAD as the default source,
but we can change that using the "--source" option
ex) git restore --source HEAD~1 home.html
This will restore the contents of home.html to its state from the commit prior to HEAD
You can also use a particular "commit hash" as the source.

Restore the file to what it looked like 2 commits prior to head
$ git restore --source HEAD~2 dog.txt

Go back to the most recent commit
$ git restore dog.txt

Restore both files to what it looked like 2 commits prior to head
$ git restore --source HEAD~2 cat.txt dog.txt

Go back to the most recent commit
$ git restore cat.txt

▶ Unstaging Files with Restore : git restore --staged <file-name>
If you have accidentally added a file to your staging area
with git add and you don't wish to include it in the next commit,
you can use git restore to remove it from staging

$ touch secret.txt
$ git add .
$ git status
result : On branch master
         Changes to be committed:
           (use "git restore --staged <file>..." to unstage)
                 modified:   cat.txt
                 modified:   dog.txt
                 new file:   secret.txt
-> 'secret.txt' is currently on the staging area

● Unstaging 'secret.txt'
$ git restore --staged secret.txt
$ git status
result : On branch master
         Changes to be committed:
           (use "git restore --staged <file>..." to unstage)
                 modified:   cat.txt
                 modified:   dog.txt

         Untracked files:
           (use "git add <file>..." to include in what will be committed)
                 secret.txt

$ git commit -m "four commit"
$ rm secret.txt

------------------------------------------------------------------------------------------

▶ Git Reset : git reset <commit-hash>
Suppose you've just made a couple of commits on the master branch,
but you actually meant to make them on a separate branch instead
To "undo those commits", you can use "git reset"
It will reset the repo back to a specific commit
The commits after are gone

● Edit 'cat.txt' and 'dog.txt' files and commit
$ git add .
$ git commit -m "mistake commit"

● Edit 'cat.txt' and 'dog.txt' files and commit
$ git add .
$ git commit -m "another bad commit"
$ git log --oneline
result : 3b6d0b3 (HEAD -> master) another bad commit
         4d35642 mistake commit
         18db2a4 four commit
         0f1469a third commit
         9f77adf second commit
         5dec360 first commit

● Go back to a specific commit
$ git reset 18db2a4
result : Unstaged changes after reset:
         M       cat.txt
         M       dog.txt

-> Edited file is not changed (keep changes)
   But, those changes now are in working directory, not in commit
   ★ You don't lose that work, but lose that commit

● Take those changes to new branch
$ git switch -c badstuff
$ git add .
$ git commit -m "add bad stuff"
 
$ git switch master

------------------------------------------------------------------------------------------

▶ Reset --hard : git reset --hard <commit>
Use the "--hard option" to undo both the commits AND the actual changes in your files
ex) "git reset --hard HEAD~1" will delete the last commit and associated changes

● Edit 'cat.txt' and 'dog.txt' files and commit
$ git add .
$ git commit -m "undo this commit please"
$ git log --oneline
result : ea4a991 (HEAD -> master) undo this commit please
         18db2a4 four commit
         0f1469a third commit
         9f77adf second commit
         5dec360 first commit

$ git reset --hard 0f1469a
$ git log --oneline
result : 0f1469a (HEAD -> master) third commit
         9f77adf second commit
         5dec360 first commit

------------------------------------------------------------------------------------------





